@ Patches iBSS sigchecks and adds a trampoline to patch iBEC command handler load address
@ Original payload by axi0mX: https://github.com/axi0mX/ipwndfu/blob/master/src/usb_0xA1_2_armv7.S
@ Uses code from greenpois0n: https://github.com/Chronic-Dev/gprc5/blob/master/syringe/syringe/exploits/limera1n/limera1n.S

.text

.pool
.set LOAD_ADDRESS,        	0xBAD00001
.set IMG_MAGIC,     	  	0xBAD00002
.set TAG_DATA,     	 	  	0xBAD00003
.set TAG_KBAG,     	  	  	0xBAD00004
.set AES_TYPE_GID,     	  	0xBAD00005
.set AES_CRYPTO_CMD,      	0xBAD00006
.set AES_MODE_256,     	  	0xBAD00007
.set GET_BOOT_TRAMPOLINE, 	0xBAD00008
.set JUMPTO,				0xBAD00009

.code 16
.global _main
_main:
jump_back:
	bkpt #1
	bkpt #1
	bkpt #1
	bkpt #1

	ldrh r2, [r0]
	movw r3, #0x2a1
	cmp  r2, r3
	bne  jump_back

	push {r4-r7,lr}
	add  r7, sp, #0xc
	sub  sp, sp, #0x10

	mov  r4, r0
	ldr  r5, =LOAD_ADDRESS

	movw r1, #0xffff
	ldrh r2, [r4,#2]
	cmp  r1, r2
	bne  request_done

	ldrd r0, r1, [r5]
	ldr  r2, =IMG_MAGIC
	cmp  r0, r2
	bne  request_done

decrypt_image:
	ldr	r0,	=LOAD_ADDRESS
	ldr	r1,	[r0, #4]	@ header->fullsize
	ldr	r2,	=TAG_DATA
	bl	img3_find_tag
	cmp	r0,	#0
	beq	request_done
	mov	r6,	r0
	ldr	r0,	=LOAD_ADDRESS
	ldr	r1,	[r0, #4]	@ header->fullsize
	ldr	r2,	=TAG_KBAG
	bl	img3_find_tag
	cmp	r0,	#0 
	beq	run_payload @ assume the image is already decrypted
	mov	r5,	r0

	mov	r0,	#0x11		@ aes_decrypt
	mov	r4,	#0x14
	add	r1,	r5,	r4
	add	r2,	r5,	r4
	mov	r3,	#0x30		@ kbag_key_iv_size
	ldr	r4,	=AES_TYPE_GID
	str	r4,	[sp]
	mov	r4,	#0
	str	r4,	[sp, #4]
	mov	r4,	#0
	str	r4,	[sp, #8]
	ldr	r4,	=AES_CRYPTO_CMD
	blx	r4

	mov	r0,	#0x11		@ aes_decrypt
	mov	r4,	#0xc
	add	r1,	r6,	r4
	add	r2,	r6,	r4
	ldr	r3,	[r6, #0x8]
	ldr	r4,	=AES_MODE_256
	str	r4,	[sp]
	mov	r4,	#0x24
	add	r4,	r5
	str	r4,	[sp, #4]
	mov	r4,	#0x14
	add	r4,	r5
	str	r4,	[sp, #8]
	ldr	r4,	=AES_CRYPTO_CMD
	blx	r4

run_payload:
	ldr r3,	=LOAD_ADDRESS
	ldr r2,	[r3, #4]
	add r2, r3
	add r2, #1
	mov	r0,	#0xc
	add	r0,	r6
	ldr	r1,	[r6, #8]
	blx r2
	mov  r0, #0
	mcr  p15, 0, r0, c7, c5, 0 
	dsb
	isb

copy_image:
	ldr	r0,	=LOAD_ADDRESS
	mov	r1,	#0xc
	add	r1,	r6
	ldr	r2,	[r6, #8]	@ header->fullsize
	bl	memcpy
	mov  r0, #0
	mcr  p15, 0, r0, c7, c5, 0 
	dsb
	isb

boot_image:
	LDR R3, =GET_BOOT_TRAMPOLINE
	BLX R3
	MOV R1, R0
	MOV R0, #0
	LDR R2, =LOAD_ADDRESS
	LDR R3, =JUMPTO
	BLX R3



request_done:
	MOV  R0, #0
	ADD  SP, SP, #0x10
	POP  {R4-R7,PC}

memcpy:

_memcpy_loop:
	ldrb	r3,	[r1]
	strb	r3,	[r0]
	add	r0,	#1
	add	r1,	#1
	sub	r2,	#1
	cmp	r2,	#0
	bne	_memcpy_loop

	bx	lr

img3_find_tag: @ (void* img3, size_t len, uint32_t tag)
	push	{r4, lr}
	add r0, #0x14 @ Set r0 to after the img3 header
	sub r1, #0x14
_img3_find_tag_loop:
	ldr r4, [r0]
	cmp	r4,	r2
	beq _img3_find_ret

_img3_find_tag_loop_continue:
	ldr r4, [r0, #0x4] @ Get the skip distance to the next tag
	add r0, r4
	sub	r1, r4
	cmp r1, #0
	bgt	_img3_find_tag_loop

	mov	r0,	#0	@ not found

_img3_find_ret:
	pop	{r4, pc}
